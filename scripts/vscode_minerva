#!/bin/bash

###############################################################################
#                                                                             #
#  Script to run on a local computer to start a code-server on Minerva and    #
#  connect it with a local browser to it                                      #
#                                                                             #
#  Minerva author : Brian Fulton-Howard                                       #
#  Main author    : Samuel Fux                                                #
#  Contributions  : Andreas Lugmayr, Mike Boss                                #
#  Date           : October 2021                                              #
#  Location       : ETH Zurich                                                #
#  Version        : 0.4.1                                                     #
#  Change history :                                                           #
#                                                                             #
#  04.07.2022    Locks have potential fix but are disabled for now            #
#  30.06.2022    Locks and free ports on remote, improved native              #
#                remote storage of reconnect info, improved messages          #
#  22.06.2022    Allow simultaneous sessions and specifying folder            #
#  22.06.2022    Automatic multiplexing and check for code-server             #
#  22.06.2022    Allow and validate longer walltimes                          #
#  16.06.2022    Adapt for minerva and add autorestart support                #
#  19.05.2022    JOBID is now saved to reconnect_info file                    #
#  28.10.2021    Initial version of the script based on Jupyter script        #
#                                                                             #
###############################################################################

###############################################################################
# Configuration options, initalising variables and setting default values     #
###############################################################################

# Version
VSC_VERSION="0.4.1"

# Script directory
# old VSC_SCRIPTDIR=$(pwd)
VSC_SCRIPTDIR=$HOME

# hostname of the cluster to connect to
if grep -q 'Host minerva[[:space:]]*$' $HOME/.ssh/config &> /dev/null; then
  VSC_HOSTNAME="minerva"
elif grep -q 'Host chimera[[:space:]]*$' $HOME/.ssh/config &> /dev/null; then
  VSC_HOSTNAME="chimera"
fi

# Queue to use
VSC_QUEUE="premium"

# LSF Account
VSC_ACCT="acc_LOAD"

# Custom job session name
VSC_SESSION=""

# order for initializing configuration options
# 1. Defaults values set inside this script
# 2. Command line options overwrite defaults
# 3. Config file options  overwrite command line options

# Configuration file default    : $HOME/.vsc_config
VSC_CONFIG_FILE="$HOME/.vsc_config"

# Number of CPU cores default   : 4 CPU cores
VSC_NUM_CPU=4

# Runtime limit default         : 12:00 hour
VSC_RUN_TIME="12:00"

# Memory default                : 4000 MB per core
VSC_MEM_PER_CPU_CORE=4000

# Waiting interval default      : 30 seconds
VSC_WAITING_INTERVAL=30

###############################################################################
# Usage instructions                                                          #
###############################################################################

function display_help {
cat <<-EOF
$0: Script to start a VSCode on Minerva from a local computer

Usage: $(basename $0) [options]

Options:

  -P | --project    acc_SOMETHING    LSF project name

Optional arguments:

  -n | --numcores   4                Number of CPU cores to be used on
                                      the cluster
  -q | --queue      premium          queue to be used on the cluster
  -W | --runtime    12               Run time limit for the code-server in hours
                                      and minutes H[H[H]]:MM
  -m | --memory     4000             Memory limit in MB per core
  -c | --config     ~/.vsc_config    Configuration file for specifying options
  -h | --help                        Display help for this script and quit
  -i | --interval   30               Time interval (sec) for checking if the job
                                      on the cluster already started
  -v | --version                     Display version of the script and exit
  -s | --server     minerva          SSH arguments for connecting to the server:
                                      Will default to "minerva", then "chimera".
                                      server name from .ssh/config, or e.g.
                                      user@minerva.hpc.mssm.edu
  -S | --session                     Session name to run multiple code servers
  -f | --folder                      Folder to open in VSCode

Examples:

  $(basename $0) -n 4 -W 04:00 -m 2048

  $(basename $0) --numcores 2 --runtime 01:30 --memory 2048

  $(basename $0) -c $HOME/.vsc_config

Format of configuration file:

VSC_NUM_CPU=1               # Number of CPU cores to be used on the cluster
VSC_RUN_TIME="01:00"        # Run time limit for the code-server in hours and
                            #   minutes H[H[H]]:MM
VSC_MEM_PER_CPU_CORE=1024   # Memory limit in MB per core
VSC_WAITING_INTERVAL=60     # Time interval to check if the job on the cluster
                            #   already started
VSC_QUEUE="premium"         # LSF queue to be used on the cluster
VSC_SESSION=""              # Session name to run multiple code servers
VSC_ACCT="acc_SOMETHING"    # LSF account to be used on the cluster
VSC_HOSTNAME="minerva"      # SSH host or username@host for connection

You should have SSH ControlMaster enabled in your ~/.ssh/config file for this to
work fully on the cluster. The script will manually multiplex otherwise, but
this is not recommended.

See https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing

EOF
exit 1
}

###############################################################################
# Parse configuration options                                                 #
###############################################################################

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
    display_help
    ;;
    -v|--version)
    echo -e "start_vscode.sh version: $VSC_VERSION\n"
    exit
    ;;
    -n|--numcores)
    VSC_NUM_CPU=$2
    shift; shift
    ;;
    -s|--server)
    VSC_HOSTNAME=$2
    shift; shift
    ;;
    -q|--queue)
    VSC_QUEUE=$2
    shift; shift
    ;;
    -P|--project)
    VSC_ACCT=$2
    shift; shift
    ;;
    -W|--runtime)
    VSC_RUN_TIME=$2
    shift; shift
    ;;
    -m|--memory)
    VSC_MEM_PER_CPU_CORE=$2
    shift; shift
    ;;
    -c|--config)
    VSC_CONFIG_FILE=$2
    shift; shift
    ;;
    -i|--interval)
    VSC_WAITING_INTERVAL=$2
    shift; shift
    ;;
    -S|--session)
    VSC_SESSION="_$2"
    shift; shift
    ;;
    -f|--folder)
    VSC_FOLDER="$2"
    shift; shift
    ;;
    *)
    echo -e "Warning: ignoring unknown option $1 \n"
    shift
    ;;
  esac
done

###############################################################################
# Check key configuration options                                             #
###############################################################################

# check if user has a configuration file and source it to initialize options
if [ -f "$VSC_CONFIG_FILE" ]; then
  echo -e "Found configuration file $VSC_CONFIG_FILE"
  echo -e "Initializing configuration from file ${VSC_CONFIG_FILE}:"
  cat "$VSC_CONFIG_FILE"
  source "$VSC_CONFIG_FILE"
fi

# Check hostname

get_hostinfo() {
    awk -v hrx="[Hh][Oo][Ss][Tt][[:space:]]+$1[[:space:]]*$" \
   '$0 ~ "[Hh]ost[[:space:]]" {a = 0} $0 ~ hrx {a = 1; next} a == 1 {print}' \
   .ssh/config | sed -E 's/^[[:blank:]]*|[[:blank:]]*$//g'
}

if [ -z ${VSC_HOSTNAME+x} ]; then
  echo -e "Hostname is not set. Please specify with --server option.\n\n"
  display_help
elif [[ "$VSC_HOSTNAME" =~ "@" ]]; then
  echo -e "Valid username and server $VSC_HOSTNAME selected\n\n"
elif ! [ -f $HOME/.ssh/config ]; then
  echo -e "Error: Username not specified and .ssh/config does not exist.\n\n"
  display_help
elif ! [[ $(get_hostinfo $VSC_HOSTNAME | wc -l) -gt 0 ]]; then
  echo -e "Error: Username not specified and host not in .ssh/config.\n\n"
  display_help
elif ! get_hostinfo $VSC_HOSTNAME | grep -iq HostName; then
  echo -e "Error: Hostname not specified in .ssh/config.\n\n"
  display_help
elif ! get_hostinfo $VSC_HOSTNAME | grep -iq User; then
  echo -e "Error: Hostname not specified in .ssh/config.\n\n"
  display_help
else
  echo -e "Connecting with the following settings:\n"
  get_hostinfo $VSC_HOSTNAME | grep -iE "HostName|User"
  echo
fi


# Check if multiplexing is enabled, otherwise warn and compensate
if ! [ -f $HOME/.ssh/config ] || \
   ! grep -q "ControlPath" $HOME/.ssh/config &> /dev/null; then
  echo -e "You should enable ControlMaster in your .ssh/config.\n"
  echo -e "See https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing\n"
  if ! [ -d $HOME/.ssh/cm_socket ]; then
    mkdir -p $HOME/.ssh/cm_socket
  fi
  VSC_MANUAL_MULTIPLEX=true
  ssh -M -S ~/.ssh/cm_socket/%r@%h:%p -o "ControlPersist=10m" $VSC_HOSTNAME echo -e "Logged in as \$USER\n"
  VSC_HOSTNAME="-S ~/.ssh/cm_socket/%r@%h:%p $VSC_HOSTNAME"
else
  scp $VSC_HOSTNAME:.reconnect_info\* $VSC_SCRIPTDIR/ &> /dev/null
fi

###############################################################################
# Check for leftover files                                                    #
###############################################################################

# check if some old files are left from a previous session and delete them

echo -e "Getting username and shell\n"

VSC_REMOTE_SHELL=$(ssh $VSC_HOSTNAME 'echo "$SHELL"' | grep -Eo '[^/]+$')

VSC_USERNAME=$(ssh $VSC_HOSTNAME 'echo "$USER"')

# check for reconnect_info in the current directory on the local computer

macos_open () {
  native_app="$HOME/.minerva_vscode_app/VSCode_minerva${VSC_SESSION}_$1-darwin-x64/VSCode_minerva${VSC_SESSION}_$1.app"
  if [[ -d $native_app ]]; then
    echo "Opening in native mode"
    open -n $native_app
  elif which nativefier &> /dev/null; then
    nativefier --quiet -n "VSCode_minerva${VSC_SESSION}_$1" \
      http://localhost:$1 .minerva_vscode_app 2> /dev/null
    echo "Opening in native mode"
    sleep 2
    open -n $native_app
  elif open -n -a 'Google Chrome' --args "--app=$1" 2> /dev/null ; then
    echo "Opened in Chromeless Google Chrome"
  else
    echo "Opening in default browser"
    open "$1"
  fi
}

echo -e "Checking if reconnection is possible\n"

if [ -f $VSC_SCRIPTDIR/.reconnect_info$VSC_SESSION ]; then
  VSC_RCI=$VSC_SCRIPTDIR/.reconnect_info$VSC_SESSION
  RC_BJOB=$(sed -nE 's/^BJOB[a-zA-Z ]+: (.+)/\1/p' $VSC_RCI)
  VSC_CHECKJOB="bjobs | grep -q $RC_BJOB && echo running || echo done"
  RC_JOBSTATE=$(ssh $VSC_HOSTNAME $VSC_CHECKJOB)
  if [[ $RC_JOBSTATE == "running" ]]; then
    token=$(ssh $VSC_HOSTNAME 'awk '\''$1 ~ "pass" {print $2}'\'' ~/.config/code-server/config.yaml')
    echo
    cat $VSC_RCI
    echo -e "Remote token      : $token"
    echo
    RC_SSH=$(sed -nE 's/^SSH[a-zA-Z ]+: (.+)/\1/p' $VSC_RCI)
    RC_URL=$(sed -nE 's/^URL[a-zA-Z ]+: (.+)/\1/p' $VSC_RCI)
    RC_PRT=$(sed -nE 's/^Local[a-zA-Z ]+: (.+)/\1/p' $VSC_RCI)

    echo -e "Starting browser and connecting it to the code-server"
    echo -e "Connecting to url $RC_URL"

    # start local browser if possible
    if [[ "$OSTYPE" == "linux-gnu" ]]; then
      lsof -i :$RC_PRT > /dev/null || $RC_SSH
      xdg-open $RC_URL
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      lsof -i :$RC_PRT > /dev/null || $RC_SSH
      macos_open $RC_PRT
    elif [[ "$OSTYPE" == "msys" ]]; then # Git Bash on Windows 10
      lsof -i :$RC_PRT > /dev/null || $RC_SSH # Don't know if this works
      start $RC_URL
    else
      echo -e "Your operating system does not allow to start the browser automatically."
      echo -e "Please open $RC_URL in your browser."
      echo -e "check if port $RC_PRT is forwarded first."
    fi
    exit 0
  else
    echo -e "Job expired; checking for left over files from previous sessions"
    echo -e "Found local session file, deleting it ..."
    rm $VSC_SCRIPTDIR/.reconnect_info$VSC_SESSION
  fi
else
  echo -e "Checking for left over files from previous sessions"
fi



# check for log files from a previous session in the home directory of the cluster

if [[ $VSC_REMOTE_SHELL == "fish" ]]; then
  ssh -T $VSC_HOSTNAME <<ENDSSH
if test -f /hpc/users/$VSC_USERNAME/.reconnect_info$VSC_SESSION
  echo -e "Found old remote session file, deleting it ..."
  rm /hpc/users/$VSC_USERNAME/.reconnect_info$VSC_SESSION
end
if test -f /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION
  echo -e "Found old vscip file, deleting it ..."
  rm /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION
end
if test -f /hpc/users/$VSC_USERNAME/.vscode$VSC_SESSION.lsf
  echo -e "Found old job file, deleting it ..."
  rm /hpc/users/$VSC_USERNAME/.vscode$VSC_SESSION.lsf
end
ENDSSH
else
  ssh -T $VSC_HOSTNAME <<ENDSSH
if [ -f /hpc/users/$VSC_USERNAME/.reconnect_info$VSC_SESSION ]; then
  echo -e "Found old remote session file, deleting it ..."
  rm /hpc/users/$VSC_USERNAME/.reconnect_info$VSC_SESSION
fi
if [ -f /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION ]; then
  echo -e "Found old vscip file, deleting it ..."
  rm /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION
fi
if [ -f /hpc/users/$VSC_USERNAME/.vscode$VSC_SESSION.lsf ]; then
  echo -e "Found old job file, deleting it ..."
  rm /hpc/users/$VSC_USERNAME/.vscode$VSC_SESSION.lsf
fi
ENDSSH
fi

echo -e "Checking for vscode on Minerva\n"

if ! ssh -tt $VSC_HOSTNAME 'bash -lc "which code-server"' &> /dev/null; then
  echo -e "code-server must be available in bash on Minerva.\n"
  echo "We suggest running 'mamba install -c conda-forge code-server' on"
  echo "Minerva if you use Anaconda and Mamba."
  exit 1
fi

###############################################################################
# Check configuration options                                                 #
###############################################################################

echo -e "Validating command line options\n"

# check number of CPU cores

# check if VSC_NUM_CPU an integer
if ! [[ "$VSC_NUM_CPU" =~ ^[0-9]+$ ]]; then
  echo -e "Error: $VSC_NUM_CPU -> Incorrect format. Please specify number of CPU cores as an integer and try again\n"
  display_help
fi

# check if VSC_NUM_CPU is <= 48
if [ "$VSC_NUM_CPU" -gt "48" ]; then
  echo -e "Error: $VSC_NUM_CPU -> Larger than 48. No distributed memory supported, therefore the number of CPU cores needs to be smaller or equal to 128\n"
  display_help
fi

if [ "$VSC_NUM_CPU" -gt "0" ]; then
  echo -e "Requesting $VSC_NUM_CPU CPU cores for running the code-server"
fi

# check if VSC_RUN_TIME is provided in HH:MM format
if [[ "$VSC_RUN_TIME" =~ ^([0-9]{1,3}):([0-9]{2})$ ]] ; then
  VSC_HOURS=${BASH_REMATCH[1]}
  VSC_MIN=$(echo ${BASH_REMATCH[2]} | sed 's/^0\(.\)$/\1/')
  VSC_MIN_TOT=$(($VSC_MIN + 60 * $VSC_HOURS))
  if [[ $VSC_MIN_TOT -gt 8640 ]] ; then
    echo -e "Error: $VSC_RUN_TIME -> Runtime limit is too long. Please try again\n"
    display_help
  fi
  echo -e "Run time limit set to $VSC_RUN_TIME"
else
  echo -e "Error: $VSC_RUN_TIME -> Incorrect format. Please specify runtime limit in the format H:MM, HH:MM, or HHH:MM and try again\n"
  display_help
fi

# check if VSC_MEM_PER_CPU_CORE is an integer
if ! [[ "$VSC_MEM_PER_CPU_CORE" =~ ^[0-9]+$ ]]; then
  echo -e "Error: $VSC_MEM_PER_CPU_CORE -> Memory limit must be an integer, please try again\n"
  display_help
else
  echo -e "Memory per core set to $VSC_MEM_PER_CPU_CORE MB"
fi

# check if VSC_WAITING_INTERVAL is an integer
if ! [[ "$VSC_WAITING_INTERVAL" =~ ^[0-9]+$ ]]; then
  echo -e "Error: $VSC_WAITING_INTERVAL -> Waiting time interval [seconds] must be an integer, please try again\n"
  display_help
else
  echo -e "Setting waiting time interval for checking the start of the job to $VSC_WAITING_INTERVAL seconds"
fi

# check if project is usable
if ! ssh $VSC_HOSTNAME mybalance | grep -q "$VSC_ACCT"; then
  echo -e "Error: You must specify a valid LSF project, please try again\n"
  display_help
fi

###############################################################################
# Start code-server on the cluster                                            #
###############################################################################

ssh $VSC_HOSTNAME "cat > .vscode$VSC_SESSION.lsf" <<<cat <<EOF
#!/usr/bin/env bash
#BSUB -J vscode$VSC_SESSION
#BSUB -P $VSC_ACCT
#BSUB -q $VSC_QUEUE
#BSUB -n $VSC_NUM_CPU
#BSUB -R span[hosts=1]
#BSUB -W $VSC_RUN_TIME
#BSUB -R rusage[mem=$VSC_MEM_PER_CPU_CORE]
#BSUB -o %J.stdout
#BSUB -eo %J.stderr
#BSUB -L /bin/bash

export http_proxy=http://172.28.7.1:3128
export https_proxy=http://172.28.7.1:3128
export all_proxy=http://172.28.7.1:3128
export no_proxy=localhost,*.chimera.hpc.mssm.edu,172.28.0.0/16
export XDG_RUNTIME_DIR="\$HOME/vsc_runtime"
VSC_IP_REMOTE="\$(hostname -i)"
echo "Remote IP:\$VSC_IP_REMOTE" >> /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION

# Lockfiles disabled for now
# lf=/tmp/vscode-session/
# mkdir -p \$lf
# if ! find \$lf -type f ! -mtime +7 ! -iname "\$USER" -exec false {} + ; then
# 	owner=\$(stat -c "%U" \$lf)
# 	if [[ \$USER != \$owner ]]; then
#     echo "FAIL" > /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION
#     echo "HOSTNAME:\$HOSTNAME" >> /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION
#     echo "OWNER:\$owner" >> /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION
#     exit 1
#   fi
# else
#   touch \$lf/\$USER
# fi


local_used_ports=\$(netstat -4 -ltn | grep LISTEN | awk '{ print \$4 }' | awk -F":" '{ print \$2 }' )

for p in {8850..9000}
do
	if [[ \$local_used_ports != *\$p* ]];
	then
		echo "Using local available port \$p"
    VSC_PORT_REMOTE=\$p
		break
	fi
done

echo "Remote Port:\$VSC_PORT_REMOTE" >> /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION

code-server --bind-addr=\${VSC_IP_REMOTE}:\$VSC_PORT_REMOTE $VSC_FOLDER
EOF


TRY=1
SUCCESS=0

while ( [ $TRY -lt 4 ] && [ $SUCCESS -eq 0 ] ); do
  # run the code-server job on Minerva and save the ip of the compute node in the file vscip in the home directory of the user on Euler
  echo -e "\nConnecting to $VSC_HOSTNAME to start the code-server in a batch job"
  VSC_BJOB_OUT=$(ssh $VSC_HOSTNAME "bsub < .vscode$VSC_SESSION.lsf")
  VSC_BJOB_ID=$(echo $VSC_BJOB_OUT | awk '/is submitted/{print substr($2, 2, length($2)-2);}')
  
  # wait until batch job has started, poll every $VSC_WAITING_INTERVAL seconds to check if /cluster/home/$VSC_USERNAME/vscip exists
  # once the file exists and is not empty the batch job has started
  echo -e "Waiting for job to start\n"
  if [[ $VSC_REMOTE_SHELL == "fish" ]]; then
  ssh -T $VSC_HOSTNAME <<ENDSSH
  while ! [ -e /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION -a -s /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION ]
    echo 'Waiting for code-server to start, sleep for $VSC_WAITING_INTERVAL sec'
    sleep $VSC_WAITING_INTERVAL
  end
ENDSSH
  else
  ssh -T $VSC_HOSTNAME <<ENDSSH
  while ! [ -e /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION -a -s /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION ]; do
    echo 'Waiting for code-server to start, sleep for $VSC_WAITING_INTERVAL sec'
    sleep $VSC_WAITING_INTERVAL
  done
ENDSSH
  fi
  
  # give the code-server a few seconds to start
  echo -e "Giving VSCode a few seconds to start\n"
  sleep 7
  
  # get remote ip, port and token from files stored on Minerva
  if ! ssh $VSC_HOSTNAME "cat /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION" | grep -q FAIL; then
    echo -e "Receiving ip and port from the code-server"
    VSC_REMOTE_IP=$(ssh $VSC_HOSTNAME "cat /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION | grep -m1 'Remote IP' | cut -d ':' -f 2")
    VSC_REMOTE_PORT=$(ssh $VSC_HOSTNAME "cat /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION | grep -m1 'Remote Port' | cut -d ':' -f 2")
    SUCCESS=1
  else
    hostname=$(ssh $VSC_HOSTNAME "cat /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION | grep -m1 'HOSTNAME' | cut -d ':' -f 2")
    owner=$(ssh $VSC_HOSTNAME "cat /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION | grep -m1 'OWNER' | cut -d ':' -f 2")
    if [ $TRY -eq 3 ]; then
      echo "$owner is running a session on $hostname, therefore execution is blocked..."
      echo "Please resubmit your job to get your job dispatched to another node. "
      echo "Change your arguments like -n -M -W slightly."
      exit 1
    else
      echo "Attempt $TRY failed due to $owner running a session on $hostname:"
      echo "Trying again"
      ssh $VSC_HOSTNAME "rm /hpc/users/$VSC_USERNAME/vscip$VSC_SESSION"
    fi
  fi
  TRY=$(($TRY+1))
done

# check if the IP, the port and the token are defined
if  [[ "$VSC_REMOTE_IP" == "" ]]; then
cat <<EOF
Error: remote ip is not defined. Terminating script.
* Please check login to the cluster and check with bjobs if the batch job on the cluster is running and terminate it with bkill.
EOF
exit 1
fi

token=$(ssh $VSC_HOSTNAME 'awk '\''$1 ~ "pass" {print $2}'\'' ~/.config/code-server/config.yaml')

# print information about IP, port and token
echo
echo -e "Remote IP address: $VSC_REMOTE_IP"
echo -e "Remote port: $VSC_REMOTE_PORT"
echo -e "Remote token: $token"
echo

# get a free port on local computer
## VSC_LOCAL_PORT=$((3 * 2**14 + RANDOM % 2**14))

echo -e "Determining free port on local computer"

find_port() {
  PRT=$1
  while ( lsof -i :$PRT -P -n | grep LISTEN &> /dev/null); do
    PRT=$((PRT+1))
  done
  echo $PRT
}

if ! [ -z ${VSC_SESSION+x} ]; then
  VSC_LOCAL_PORT=$(find_port 8890)
else
  VSC_LOCAL_PORT=$(find_port 8899)
fi

echo -e "Using local port: $VSC_LOCAL_PORT"

# write reconnect_info file
cat <<EOF > $VSC_SCRIPTDIR/.reconnect_info$VSC_SESSION
Restart file
Remote IP address : $VSC_REMOTE_IP
Remote port       : $VSC_REMOTE_PORT
Local port        : $VSC_LOCAL_PORT
SSH tunnel        : ssh $VSC_HOSTNAME -L $VSC_LOCAL_PORT:$VSC_REMOTE_IP:$VSC_REMOTE_PORT -N &
URL               : http://localhost:$VSC_LOCAL_PORT
BJOB ID           : $VSC_BJOB_ID
EOF

# setup SSH tunnel from local computer to compute node via login node
# FIXME: check if the tunnel can be managed via this script (opening, closing) by using a control socket from SSH
echo -e "Setting up SSH tunnel for connecting the browser to the code-server"
ssh $VSC_HOSTNAME -L $VSC_LOCAL_PORT:$VSC_REMOTE_IP:$VSC_REMOTE_PORT -N &

# SSH tunnel is started in the background, pause 5 seconds to make sure
# it is established before starting the browser
sleep 5

# Copy connection information to the remote machine
if [ -z ${VSC_MANUAL_MULTIPLEX+x} ]; then
  scp $VSC_SCRIPTDIR/.reconnect_info$VSC_SESSION \
    $VSC_HOSTNAME:.reconnect_info$VSC_SESSION &> /dev/null
fi

# save url in variable
VSC_URL=http://localhost:$VSC_LOCAL_PORT
echo -e "Starting browser and connecting it to the code-server"
echo -e "Connecting to url $VSC_URL"

# start local browser if possible
if [[ "$OSTYPE" == "linux-gnu" ]]; then
  xdg-open $VSC_URL
elif [[ "$OSTYPE" == "darwin"* ]]; then
  macos_open $VSC_LOCAL_PORT
elif [[ "$OSTYPE" == "msys" ]]; then # Git Bash on Windows 10
  start $VSC_URL
else
  echo -e "Your operating system does not allow to start the browser automatically."
  echo -e "Please open $VSC_URL in your browser."
fi
